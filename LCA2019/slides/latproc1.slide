latproc (Language And Tools for Process Control)
	-- TODO add image of bales on gravity feed from Ron spec docuement
	First published 2012
	-- latproc project is used for process control of hydraulic and pyneumatic machinery.
	-- Developed intitally for Wooltech Wool Sampling machines
	Linux hosted
	Open Source under BSD and GPL
	Developed a languaged which we call Clockwork
	-- which we will talk about later

Capabilties
	BeckHoff EtherCAT(tm) based control
	-- Current able to interface to Ethercat Industrial Hardware
	-- Very high speed updated rates
	Humid
	-- Human Interface Device
	Protocols
	-- Number of protcols both indusralia in nature and custom using tcp/ip and plugins
		Modbus master/slave
		Raw TCP/IP and serial UART (device_connector)
		Plugins
			- libcurl
			- exec system
		MQTT
	-- Why would we do this, lets go back

Going Back
	Wooltech - 40 years of automation
	Electrical time and relay logic
	Scorpion board John langford and lots of extra boards
	Custom Zilog Z80 board with inputs and relays
	Early PLCs by Koyo (rebadged by GE and others)
	Custom software ron Linux (late 90s) 
	Back to Koyo PLC's during the 2000s using newer models

	-- Wooltech has 40 years of develop machines that needed control
	-- From electrical time and relay logic, to a Scorpion board
	-- and then a Zilog Z80-based board with inputs and relays
	-- that was programmed with a macro-assembler. 
	-- Early Koyo based PLCs were used by Wooltech up to about 1995 with a second series developed 
	-- After trying a linux based C++ system we built a few more 
	-- machines using newer models of the Koyo PLCs

Issues we Experienced
	Long Term Hardware support is hard

	Closed binary file formats for hardware programming
	Industrial hardware is upgraded with forward only compaltible file formats.
	External expertise often required
		Initially in building controller boards
		Later in writing control software
	Hard to find industrially experienced coders
	-- The machines that Wooltech build tend to be in service for 20 years or so
	-- before they receive any major servicing or refurbishment. Over that period
	-- Lots of things change with the components that make up the machinery
	-- Even from a programming point of view, it is 
	-- hard to maintain a relationship with external people for software maintenance
	-- without large amount of ongoing work.
	-- We do not like to have to depend on external people for our core business, especially where support and
	-- onging maintenance activities are needed.

What did we Do?
	Moved to a Linux based solution
	Programmed a solution with custom messaging and communications
	Programming took too long
	Result was not really what we wanted
	Program was not very reusable
	We discovered state machines
	We went back to PLCs

	-- At first when we moved towards uing a Linux-based control
	-- system we had some software developed in C++ along with a custom
	-- messaging system between components.
	-- Overall, software produced met the performace requirements
	-- but we really needed more of a reusable softer driver
	-- rather than a monolithic application.

	-- A good thing that came out of the process was that we learnt about state machines

Our Requirements
	Retain Control
	Reduce Risk
	Be Future-proof
	Resuse Don't Rewrite
	Version Control all source code

	-- Wooltech found the control develop risks for new/refusbished sampling lines became 
	-- so prohibitive that we considered moving to other industries.

	-- As part of another project a past colleague, Martin Leadbeater, provided some help 
	-- with building system health monitoring software within some embedded Linux boxes
	-- I was building. His approach was to use a Domain Specific Language in an attempt
	-- to make it easy to write scripts that monitor the state of various subsystems
	-- within the Linux hosts. 

	-- Together we discussed whether a similar approach might work for the control of
	-- a new machine that Wooltech was being asked to build.
	-- After some initial exploration, Martin's design for a Domain Specific Language
	-- started to take shape and clockwork was born.

Retaining Control
	Simple programming language
	Program pieces are called MACHINEs
	Machines can be simulated easily
	Machine stated resemble physical states and behaviour

	-- The design is based on what we have learnt
	-- programming using state machines and PLCs over many years
	-- and the business experance before that using a Zilog Z80 platform with custom BIOS and compiler

	-- We have found Clockwork a very effective language to model and control 
	-- machinery. We can write the code for our machines ourselves without
	-- needing to engage ourside help even when the processing logic is complex.

	-- When writing the code, we think of the bahaviour of individual parts of the equipment
	-- We write clockwork code that represents our understanding of the machine
	-- behaviour. For example, if a device on the machine can be 'up' or 'down' we
	-- define a MACHINE in clockwork that has an 'UP' state and a 'DOWN' state.
	-- If we want to model movement or we want to control the device, we 
	-- might also add states like 'Moving Up' or 'Moving Down'
	-- We find this direct relationship between the software and the hardware
	-- to be have advantages in coding and also in talking about the 
	-- program and how the machine should behave even with team members who 
	-- are not programmers.

Reducing Risk
	By programming ourselves
	By simulating as we develop
	By resuing what we have done before

	-- We understand our machinery better than other people and we
	-- understand the most effective way it should be used. 
	-- By programming the control ourselves we can be sure that
	-- the machine will be useable and we can control the 
	-- development process.

	-- Clockwork makes it fairly simple to simulate components
	-- of the system and this makes it possible to develop most
	-- of the code while the machine is being built.

	-- By reusing what we have, simulating as we go and due to 
	-- the powerful debugging features we are able to program
	-- the main control for new machines in a few weeks.



Future-proofing
	Use Linux
	Use Open Source Software


Version Control everything
	Proprietary, binary data formats make version control impossible
	Over time PLC software or HMI panel firmware changes
	Proprietary, windows-based programming tools do not maintain support for all versions 

	-- Building machinery over an extended period of time leads to situatons where
	-- some sites have one version of a PLC programming tool and others have a different version
	-- This creates a version control nightmare of 10 installed system each using different 
	-- hardware / software tools and trying to maintain a single code base is impoissalbe.


Debugging
	Effective debugging tools
		State Description
		Predicate exmplaiotn
		contiunes sampling of the state and propties changes.
	-- Clockworks tools for debugging are highly effective and are bases round current state description along with explantion 




