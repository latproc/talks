Clockwork
	Clockwork And Its Tools - Open Source Software to make things more easily
	Mike O'Connor
latproc 
	Language And Tools for Process Control
	-- TODO add image of bales on gravity feed from Ron spec document

		First published 2012
	-- latproc project is used for process control of hydraulic and pneumatic machinery.
	-- Developed initially for Wooltech Wool Sampling machines
		Linux hosted
		Open Source under BSD and GPL
		Developed a language which we call Clockwork
	-- which we will talk about later

Original Design Capabilities
	Industrial IO (real world connections)
		BeckHoff EtherCAT(tm) based control
	-- Current able to interface to Ethercat Industrial Hardware
	-- Very high speed updated rates
	Humid (Human Machine Interface)
	-- Human Interface Device
	Protocols
	-- Number of protocols both industrial in nature and custom using TCP/IP and plugins
		Modbus master/slave
		Raw TCP/IP and serial UART (device_connector)
		Plugins
			- libcurl
			- exec system
		MQTT

What it was develop for
	<img src="img/MosesInfeedFrontRHV2.jpg">




Clockwork
	The latproc language
	Objects are called 'Machine's
	Describe Machines by their states
	States are selected by evaluating rules
	All Machines run continuously in parallel
	Machines monitor each other

Language Features
	Rule based
	Automatic state selection
	No Loop statements
	Highly reusable code

	-- There are a few key features that distinguish our 
	-- clockwork language. It uses rules to automatically
	-- decide what state parts of a system are in.

	-- It is highly parallel and since clockwork components
	-- run continuously there is no need for loops

	-- We find that the components we build tend to be 
	-- easy to reuse.

Defining states
	###
	Light MACHINE {
		on STATE;
		off INITIAL;
	}
	###
	Simple machine
	No automation
	Controlled externally

	-- this describes a machine that can be on or off, initially it is off
	-- This machine does not have any automation, it has to be
	-- controlled externally by directly setting its state.

Using transitions

	###
	ToggleSwitch MACHINE {
		on STATE;
		off INITIAL;

		TRANSITION on TO off USING next;
		TRANSITION off TO on USING next;
	}
	###
	Basic automation via transitions
	Flips state when 'next' message is received

	-- this dscribes a machine that can receive a message called: 'next'

	-- if this machine receives the message, when it is on, it turns off.
	-- Similarly, if it was off when the message arrives, it turns on.

	-- repeatedly sending the next message will cause the machine to
	-- toggle between on and off

Situation Normal
	MACHINEs can have STATEs
	TRANSITIONS can cause STATEs to change
	Nothing special so far...

	-- this is all very common and is what all state-based programming
	-- is like. Essentially, transitions are used to respond to 
	-- events and programming using state machines is all about 
	-- sending and responding to events.

	-- Clockwork is not like this and actually we rarely use the
	-- TRANSITION statement.

Using rules

	###
	Blinker MACHINE {
		on WHEN SELF IS off;
		off DEFAULT;
	}
	###
	Automatic state selection
	Evaluates rules in sequence
	Stops at the first rule that is true

	-- here is a machine that has two states, 'on' and 'off'

	-- the 'on' state has a rule given by the WHEN clause

	-- the machine continuously evaluates its rules and none of them
	-- match (that is, if none of them evaluate as 'TRUE') then
	-- the machine sets itself into the DEFAULT state.

	-- Looking at the rule on this machine, we see that whenever
	-- the machine is 'off', the rule for the 'on' state is TRUE
	-- so the machine turns on. 

	-- If the machine is on, the rule 'SELF IS off' is no longer true so
	-- the machine cannot stay in the 'on' state. Since there are
	-- no other states, the machine goes to 'off'

Controlling things

	###
	LightSwitch MACHINE switch, light {
		on WHEN switch IS on;
		off DEFAULT;

		ENTER on  { SET light TO on; }
		ENTER off { SET light TO off; }
	}
	###
	Controls 'light' based on the state of 'switch'

	-- When a machine changes state, it check to see if it has to do anything
	-- by looking for an ENTER statement for the new state. 

	-- In this example, we are controlling a light using about
	-- switch.

	-- When the switch is turned on, this controller turns the light on.

	-- In clockwork, the switch and the light could be other software 'MACHINE's or
	-- they could represent hardware devices, such as switches, beams or proximity sensors
	-- They might even represent the value of a topic in an IoT device.

No Loops or Ifs?

	###
	Counter MACHINE {
		OPTION count 0;
		up WHEN count < 10;
		idle DEFAULT;

		ENTER up { count := count + 1; }
	}
	###

	-- There is no while statement, for statement or repeat statement in clockwork
	-- everything is accomplished with state changes.

	-- In this example, we show a machine that counts up to 10 without a loops

	-- Actually this example has a bug. When the machine starts its count property is set to zero.
	-- The rules are checked and 'count < 10' is true so the machine enters the 'up' state

	-- When the machine enters the up state, it adds one to count.

	-- Next time the rules are evaluated, count is still < 10 to the machine stays
	-- in the 'up' state.

	-- Since it has already entered the 'up' state, the machine does not execute the
	-- ENTER function for 'up' so the machine is stable and sits in the 'up' 
	-- state forever.


No If statements?

	###
	Counter MACHINE {
		OPTION count 0;
		up WHEN count < 10;
		idle DEFAULT;

		ENTER up { 
			count := count + 1;
			IF count < 10 { SET SELF TO idle; }
		}
	}
	###

	An ugly fix to the error in the rules

	-- actually, clockwork has if statements but we almost never use them

	-- this example fixes the previous bug using an IF statement.

	-- usually if we think we need to use an if statement, we haven'that
	-- got the rules right.

Counting up

	###
	Counter MACHINE {
		OPTION count 0;
		up WHEN SELF IS idle AND count < 10;
		idle DEFAULT;

		ENTER up { count := count + 1; }
	}
	###

	-- this example fixes the bug in the previous example.

	-- note that it is a lot cleaner and doesn't need an if statement

Reusing components

	###
	LightSwitch MACHINE switch, light {
		on WHEN switch IS on;
		off DEFAULT;

		ENTER on  { SET light TO on; }
		ENTER off { SET light TO off; }
	}
	###

	-- When machine are linked together, it is important to make
	-- sure that they have the states and properties that are used in 
	-- all of the rules and ENTER functions

	-- for example, the machine passed to the LightSwitch must have a state 
	-- called 'on' so it can be test in the rules.

	-- similarly, the machine connected as 'light' must have an 'on' state and an 'off' state
	-- It may have other states of its own also but LightSwitch doesn't care about that.

	-- It turns out that this simple way of connecting machines to each other this
	-- way means a component (such as this LightSwitch) can be placed in a 
	-- library and reused


Controlling multiple things at once

	###
	LightController MACHINE lights {
		COMMAND on  { SEND turnOn TO lights; }
		COMMAND off { SEND turnOff TO lights; }
	}

	front_porch Light;
	garden Light;
	yard_lights LIST front_porch, garden;

	controller LightController yard_lights;
	###

	-- this example shows how some lights can be built into a list and
	-- that list can be connected to a controller machine

	-- when a message is sent to a LIST, the message is actually
	-- sent to all of the devices built into the LIST

Tools
	iod - main EtherCAT control daemon
	cw - local interpreter daemon
	iosh - terminal shell
	sampler - monitoring and logging
	persistd - monitor and retain persistend state
	modbusd - bridge to modbus masters (panels)
	device connector - bridge to TCP/IP or serial devices
Tools
	iosh
	###
> DESCRIBE O24V_GrabControlFan ;
---------------
O24V_GrabControlFan: off  Class: POINT 
 instantiated at: /opt/latproc/code/config/config.lpc line:94
  parameter 1 module (EL2828_01), state: OP
  parameter 2 1 ()

 io: readtime: 185932 [Channel 2 Output, 1 0:1.1]=0 (0)
Exports:
  O24V_GrabControlFan
  published (1)
Listening to: 
  EL2828_01[123]:   OP

Dependant machines: 
  L_Inputs[399]:   nonempty
  M_ControlFan[580]:   off

properties:
  NAME:O24V_GrabControlFan, STATE:off, export:0, tab:Outputs, type:Output, wire:Y52

Timer: 20713486

>
	###

Tools
	sampler
	###
443391 M_CO2 idle
443891 M_CO2 update
443892 XA_CO2 CO2_Level 496
443892 XA_CO2 message 496
443892 M_CO2 idle
	###
	-- sampler captures a stream of state and property changes
	-- extermally effective debug tool

User Interface Tools 
	Web UI - basic web applicationfor monitoring and control
	humid - GUI development tool
		Buttons (toggle, momentary)
		Text and Number Entry Fields
		Page switching
		Element visablity control
		Time series graphing
	web 3D visualisation - render a model in 3D
	scope - character based graphing for sampler 

	-- The original user interface we a basic web page that 
	-- displayed the status of the IO on separate tabs, 
	-- for example a tab for Inputs and one for Outputs
	-- Each Clockwork machine can have a parameter that
	-- indicates where it's status should be displayed.

	-- Lately we have been using a new tool, Humid, that
	-- provides standard user interface tools and
	-- also includes features for real-time graphing
	-- of time-series data and can display images
	-- from web cameras or other sites.

	-- We have demonstrated how to render and control
	-- 3D models of the machinery but this is not
	-- something we do for normal user interfaces

Open Source components
	Linux, GNU compiler suite
	cJSON, libmodbus, ZeroMQ
	EtherLAB, libXML, three.js
	nanogui, glfw
	etc.,

	-- these are some of the Open Source tools we use within the latproc tool set
