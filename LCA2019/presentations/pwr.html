<!doctype html>
<html>

<head>
	<meta charset="utf-8">

	<title>Latproc - Language and Tools for Process Control</title>

	<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
	<meta name="author" content="Mike O'Connor">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/lca2019.css" id="theme">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>

	<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

	<style>
		/*********************************************
			* ZOOM REVERSE TRANSITION (i.e. zoom out)
			*********************************************/
			.reveal .slides section[data-transition=zoomrev],
			.reveal.zoomrev .slides section:not([data-transition]) {
				transition-timing-function: ease;
			}

			.reveal .slides > section[data-transition=zoomrev].past,
			.reveal .slides > section[data-transition~=zoomrev-out].past,
			.reveal.zoomrev .slides > section:not([data-transition]).past {
				       visibility: hidden;
				-webkit-transform: scale(0.2);
						transform: scale(0.2);
			}

			.reveal .slides > section[data-transition=zoomrev].future,
			.reveal .slides > section[data-transition~=zoomrev-in].future,
			.reveal.zoomrev .slides > section:not([data-transition]).future {
					   visibility: hidden;
				-webkit-transform: scale(16);
						transform: scale(16);
			}

			.reveal .slides > section > section[data-transition=zoomrev].past,
			.reveal .slides > section > section[data-transition~=zoomrev-out].past,
			.reveal.zoomrev .slides > section > section:not([data-transition]).past {
				-webkit-transform: translate(0, 150%);
						transform: translate(0, 150%);
			}

			.reveal .slides > section > section[data-transition=zoomrev].future,
			.reveal .slides > section > section[data-transition~=zoomrev-in].future,
			.reveal.zoomrev .slides > section > section:not([data-transition]).future {
				-webkit-transform: translate(0, -150%);
						transform: translate(0, -150%);
			}
		</style>

</head>

<body>

	<!-- Start of main presentation -->
	<div class="reveal">
		<div class="footer theme footer-green" id="lca-footer">
				<div class="left-side">
					<div><b>LINUX.CONF.AU</b></div>
					<div><span>21-25 January 2019 | Christchurch | NZ</span></div>
				</div>
				<div class="right-side">
					<div><b>The Linux of Things</b></div>
					<div class="hashtag">#LCA2019</span><span class="twitter">@linuxconfau</span></div>
				</div>
				<div style="clear:both"></div>
		</div>
		<!-- include user data between here... -->
<div class="slides">
<section style="text-align: left;"  data-state="title-slide" data-background-image="css/theme/lca2019-title-bg-transparent.svg">
	<h2>Clockwork</h2>
	<p>
	Programming with rules
	</p>
	<p>
	Mike O'Connor
	</p>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>latproc </h2>
	<p>
	Language And Tools for Process Control
	</p>
	<aside class="notes">
		 TODO add image of bales on gravity feed from Ron spec document
</aside>
	<ul>
	<li>		First published 2012</li>
	
	<aside class="notes">
		 latproc project is used for process control of hydraulic and pneumatic machinery.
		 Developed initially for Wooltech Wool Sampling machines
</aside>
	<li>		Linux hosted</li>
	
	<li>		Open Source under BSD and GPL</li>
	
	<li>		Developed a language which we call Clockwork</li>
	
	<aside class="notes">
		 which we will talk about later
<br/>
	</ul>
	</aside>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>Capabilities</h2>
	<p>
	Industrial IO (real world connections)
	</p>
	<ul>
	<li>		BeckHoff EtherCAT(tm) based control</li>
	
	<aside class="notes">
		 Current able to interface to Ethercat Industrial Hardware
		 Very high speed updated rates
</aside>
	</ul>
	<p>
	Humid (Human Machine Interface)
	</p>
	<aside class="notes">
		 Human Interface Device
</aside>
	<p>
	Protocols
	</p>
	<aside class="notes">
		 Number of protocols both industrial in nature and custom using TCP/IP and plugins
</aside>
	<ul>
	<li>		Modbus master/slave</li>
	
	<li>		Raw TCP/IP and serial UART (device_connector)</li>
	
	<li>		Plugins</li>
	
	<li>			- libcurl</li>
	
	<li>			- exec system</li>
	
	<li>		MQTT</li>
	
	<aside class="notes">
		 Why would we do this, lets go back
<br/>
	</ul>
	</aside>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>Going Back</h2>
	<p>
	Wooltech - 40 years of automation
	</p>
	<p>
	Electrical time and relay logic
	</p>
	<p>
	Scorpion board John Langford and lots of extra boards
	</p>
	<p>
	Custom Zilog Z80 board with inputs and relays
	</p>
	<p>
	Early PLCs by Koyo (rebadged by GE and others)
	</p>
	<p>
	Custom software on Linux (late 90s) 
	</p>
	<p>
	Back to Koyo PLCs during the 2000s using newer models
	</p>

	<aside class="notes">
		 Wooltech has 40 years of develop machines that needed control
		 From electrical time and relay logic, to a Scorpion board
		 and then a Zilog Z80-based board with inputs and relays
		 that was programmed with a macro-assembler. 
		 Early Koyo based PLCs were used by Wooltech up to about 1995 with a second series developed 
		 After trying a Linux based C++ system we built a few more 
		 machines using newer models of the Koyo PLCs
<br/>
	</aside>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>Issues we Experienced</h2>
	<p>
	Long term custom hardware support is hard
	</p>

	<p>
	Commerical solutions use binary file formats for source config
	</p>
	<p>
	Industrial hardware is upgraded with forward only source formats.
	</p>
	<p>
	External expertise often required
	</p>
	<ul>
	<li>		Initially in building controller boards</li>
	
	<li>		Later in writing control software</li>
	
	</ul>
	<p>
	Hard to find industrially experienced coders
	</p>
	<aside class="notes">
		 The machines that Wooltech build tend to be in service for 20 years or so
		 before they receive any major servicing or refurbishment. Over that period
		 lots of things change with the components that make up the machinery
		 even from a programming point of view, it is 
		 hard to maintain a relationship with external people for software maintenance
		 without large amount of ongoing work.
		 We do not like to have to depend on external people for our core business, especially where support and
		 ongoing maintenance activities are needed.
<br/>
	</aside>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>What did we Do?</h2>
	<p>
	(the first attempt)
	</p>
	<ul>
	<li>		Moved to a Linux based solution</li>
	
	<li>		Programmed a solution with custom messaging and communications</li>
	
	<li>		Programming took too long</li>
	
	<li>		Result was not really what we wanted</li>
	
	<li>		Program was not very reusable</li>
	
	<li>		We discovered state machines</li>
	
	<li>		We went back to PLCs</li>
	

	<aside class="notes">
		 At first when we moved towards using a Linux-based control
		 system we had some software developed in C++ along with a custom
		 messaging system between components.
		 Overall, software produced met the performance requirements
		 but we really needed more of a reusable softer driver
		 rather than a monolithic application.
<br/>
		 A good thing that came out of the process was that we learnt about state machines
<br/>
	</ul>
	</aside>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>Our Requirements</h2>
	<p>
	Retain control
	</p>
	<p>
	Reduce risk
	</p>
	<p>
	Be future-proof
	</p>
	<p>
	Reuse Don't Rewrite
	</p>
	<p>
	Version control all source code
	</p>

	<aside class="notes">
		 Wooltech found the control development risks for 
		 new/refurbished sampling lines became 
		 so prohibitive that we considered moving to other industries.
<br/>
		 As part of another project a past colleague, Martin Leadbeater, provided some help 
		 with building system health monitoring software within some embedded Linux boxes
		 I was building. His approach was to use a Domain Specific Language in an attempt
		 to make it easy to write scripts that monitor the state of various subsystems
		 within the Linux hosts. 
<br/>
		 Together we discussed whether a similar approach might work for the control of
		 a new machine that Wooltech was being asked to build.
		 After some initial exploration, Martin's design for a Domain Specific Language
		 started to take shape and clockwork was born.
<br/>
	</aside>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>Starting again</h2>
	<p>
	Simple programming language
	</p>
	<p>
	Program pieces are called MACHINEs
	</p>
	<p>
	Machines can be simulated easily
	</p>
	<p>
	A Machines state resemble physical states and behaviour
	</p>

</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>        ###</h2>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>        LightSwitch MACHINE switch, light {</h2>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>                on WHEN switch IS on;</h2>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>                off DEFAULT;</h2>

</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>                ENTER on  { SET light TO on; }</h2>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>                ENTER off { SET light TO off; }</h2>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>        }</h2>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>        ###</h2>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>        Controls 'light' based on the state of 'switch'</h2>


	<aside class="notes">
		 The design is based on what we have learnt
		 programming using state machines and PLCs over many years
		 and the business experience before that using a Zilog Z80 platform with custom BIOS and compiler
<br/>
		 We have found Clockwork a very effective language to model and control 
		 machinery. We can write the code for our machines ourselves without
		 needing to engage outside help even when the processing logic is complex.
<br/>
		 When writing the code, we think of the behaviour of individual parts of the equipment
		 We write clockwork code that represents our understanding of the machine
		 behaviour. For example, if a device on the machine can be 'up' or 'down' we
		 define a MACHINE in clockwork that has an 'UP' state and a 'DOWN' state.
		 If we want to model movement or we want to control the device, we 
		 might also add states like 'Moving Up' or 'Moving Down'
		 We find this direct relationship between the software and the hardware
		 to be have advantages in coding and also in talking about the 
		 program and how the machine should behave even with team members who 
		 are not programmers.
<br/>
	</aside>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>Reducing Risk</h2>
	<p>
	By programming ourselves
	</p>
	<p>
	By simulating as we develop
	</p>
	<p>
	By reusing what we have done before
	</p>

	<aside class="notes">
		 We understand our machinery better than other people and we
		 understand the most effective way it should be used. 
		 By programming the control ourselves we can be sure that
		 the machine will be usable and we can control the 
		 development process.
<br/>
		 Clockwork makes it fairly simple to simulate components
		 of the system and this makes it possible to develop most
		 of the code while the machine is being built.
<br/>
		 By reusing what we have, simulating as we go and due to 
		 the powerful debugging features we are able to program
		 the main control for new machines in a few weeks.
<br/>
<br/>
<br/>
	</aside>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>Future-proofing</h2>
	<p>
	Use Linux
	</p>
	<p>
	Use Open Source Software
	</p>


</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>Version Control everything</h2>
	<p>
	Proprietary, binary data formats make version control impossible
	</p>
	<p>
	Over time PLC software or HMI panel firmware changes
	</p>
	<p>
	Proprietary, windows-based programming tools do not maintain support for all versions 
	</p>

	<aside class="notes">
		 Building machinery over an extended period of time leads to situations where
		 some sites have one version of a PLC programming tool and others have a different version
		 This creates a version control nightmare of 10 installed system each using different 
		 hardware / software tools and trying to maintain a single code base is impossible.
<br/>
<br/>
	</aside>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>Debugging</h2>
	<p>
	Effective debugging tools
	</p>
	<ul>
	<li>		State Description</li>
	
	<li>		Predicate explanation</li>
	
	<li>		continues sampling of the state and properties changes.</li>
	
	<aside class="notes">
		 Clockworks tools for debugging are highly effective and are bases round current state description along with explanation 
<br/>
<br/>
<br/>
<br/>
	</ul>
	</aside>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>Clockwork</h2>
	<p>
	The latproc language
	</p>
	<p>
	Objects are called 'Machine's
	</p>
	<p>
	Describe Machines by their states
	</p>
	<p>
	States are selected by evaluating rules
	</p>
	<p>
	All Machines run continuously in parallel
	</p>
	<p>
	Machines monitor each other
	</p>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>Tools</h2>
	<p>
	iod - main EtherCAT control daemon
	</p>
	<p>
	cw - local interpreter daemon
	</p>
	<p>
	iosh - terminal shell
	</p>
	<p>
	sampler - monitoring and logging
	</p>
	<p>
	persistd - monitor and retain persistend state
	</p>
	<p>
	modbusd - bridge to modbus masters (panels)
	</p>
	<p>
	device connector - bridge to TCP/IP or serial devices
	</p>

</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>User Interface Tools </h2>
	<p>
	Web UI - basic web applicationfor monitoring and control
	</p>
	<p>
	humid - GUI development tool
	</p>
	<p>
	web 3D visualisation - render a model in 3D
	</p>
	<p>
	scope - character based graphing for sampler 
	</p>

	<aside class="notes">
		 The original user interface we a basic web page that 
		 displayed the status of the IO on separate tabs, 
		 for example a tab for Inputs and one for Outputs
		 Each Clockwork machine can have a parameter that
		 indicates where it's status should be displayed.
<br/>
		 Lately we have been using a new tool, Humid, that
		 provides standard user interface tools and
		 also includes features for real-time graphing
		 of time-series data and can display images
		 from web cameras or other sites.
<br/>
		 We have demonstrated how to render and control
		 3D models of the machinery but this is not
		 something we do for normal user interfaces
<br/>
	</aside>
</section>
<section class="lca-slide"  data-state="normal-slide" >
	<h2>Open Source components</h2>
	<p>
	Linux, GNU compiler suite
	</p>
	<p>
	cJSON, libmodbus, ZeroMQ
	</p>
	<p>
	EtherLAB, libXML, three.js
	</p>
	<p>
	nanogui, glfw
	</p>
	<p>
	etc.,
	</p>

	<aside class="notes">
		 these are some of the Open Source tools we use within the latproc tool set
</section>
</div>
		<!-- ... and here -->
		
	</div> <!-- class="reveal" -->
	<!-- End of main presentation -->

	<!-- Start of configuration section -->
	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
		var presenter = !!Reveal.getQueryHash().s;

		// More info https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: presenter ? false : true,
			progress: true,
			history: true,
			center: true,
			controlsTutorial: presenter ? false : true,

			slideNumber: presenter ? null : 'c/t',

			// The "normal" size of the presentation, aspect ratio will be preserved
			// when the presentation is scaled to fit different resolutions. Can be
			// specified using percentage units.
			width: 960,
			height: 700,

			// Factor of the display size that should remain empty around the content
			margin: 0.1,

			multiplex: {
				url: 'https://p.xobs.io/',
				id: '631bb3db6fbaea78',
				secret: Reveal.getQueryHash().s || null
			},

			// Bounds for smallest/largest possible scale to apply to content
			minScale: 0.02,
			maxScale: 5.5,

			transition: 'slide', // none/fade/slide/convex/concave/zoom

			// More info https://github.com/hakimel/reveal.js#dependencies
			dependencies: [
				{ src: 'lib/js/classList.js', condition: function () { return !document.body.classList; } },
				{ src: 'plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
				{ src: 'plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
				{ src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } },
				{ src: 'plugin/search/search.js', async: true },
				{ src: 'plugin/zoom-js/zoom.js', async: true },
				{ src: 'plugin/notes/notes.js', async: true },

				{ src: 'lib/js/socket.io.js', async: true },
				{
					src: presenter ?
						'plugin/multiplex/master.js' :
						'plugin/multiplex/client.js', async: true
				},
			]
		});
		Reveal.addEventListener( 'title-slide', function() {
			var footer = document.getElementById("lca-footer");
			footer.classList.remove("footer-white");
			footer.classList.add("footer-green");
			document.body.style.background = "#387A3B"
		} );
		Reveal.addEventListener( 'normal-slide', function() {
			var footer = document.getElementById("lca-footer");
			footer.classList.remove("footer-green");
			footer.classList.add("footer-white");
			document.body.style.background = "#fff"
		} );

	</script>
</body>

</html>
